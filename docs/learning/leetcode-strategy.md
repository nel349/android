# LeetCode Strategy

Your structured path to solving 200 problems in 6 months and crushing FAANG coding interviews.

---

## The Goal: 200 Problems in 6 Months

**Distribution:**
- **40 Easy** (20%) - Foundation, confidence building
- **120 Medium** (60%) - Interview bread-and-butter
- **40 Hard** (20%) - Advanced patterns, competitive edge

**Timeline:**
- **Month 1:** 28 problems (mostly easy, some medium)
- **Month 2:** 28 problems (medium focus)
- **Month 3:** 44 problems (medium/hard mix)
- **Month 4:** 50 problems (hard focus)
- **Month 5:** 30 problems (maintenance + company-specific)
- **Month 6:** 20 problems (contest practice, timed)

**Why 200?** Enough to see all major patterns, not so many you burn out. Quality > quantity.

---

## Monthly Focus Areas

### Month 1: Foundation (28 problems - 20 easy, 8 medium)

**Week 1 (7 easy): Arrays & Strings**
- ~~Two Sum~~, ~~Valid Anagram~~, ~~Group Anagrams~~
- ~~Best Time to Buy/Sell Stock~~, ~~Contains Duplicate~~
- Valid Palindrome, Longest Substring Without Repeating

**Patterns:** Hash maps, two pointers, sliding window basics

**Week 2 (7 easy/medium): HashMaps & Two Pointers**
- Roman to Integer, Integer to Roman
- Container With Most Water, 3Sum
- Longest Palindromic Substring

**Patterns:** Hash map tricks, two pointer optimization

**Week 3 (7 medium): Linked Lists & Stacks**
- Reverse Linked List, Merge Two Sorted Lists
- Linked List Cycle, Remove Nth Node
- Valid Parentheses, Min Stack, Evaluate Reverse Polish Notation

**Patterns:** Fast/slow pointers, stack for matching

**Week 4 (7 medium): Trees & Binary Search**
- Maximum Depth of Binary Tree, Same Tree, Invert Binary Tree
- Binary Search, Search in Rotated Sorted Array
- Kth Largest Element

**Patterns:** DFS, BFS, binary search variations

**Month 1 Goal:** 28/200 (14%) - Foundation complete, confidence built

---

### Month 2: Depth (28 problems - 4 easy, 24 medium)

**Week 5 (7 medium): DFS/BFS**
- Number of Islands, Clone Graph
- Pacific Atlantic Water Flow
- Course Schedule, Course Schedule II

**Patterns:** Graph traversal, topological sort, visited tracking

**Week 6 (7 medium): Dynamic Programming (Intro)**
- Climbing Stairs, House Robber, House Robber II
- Coin Change, Longest Increasing Subsequence
- Word Break

**Patterns:** 1D DP, state transitions, memoization

**Week 7 (7 medium): More DP**
- Unique Paths, Longest Palindromic Substring
- Decode Ways, Maximum Product Subarray
- Partition Equal Subset Sum

**Patterns:** 2D DP, subarray/substring DP

**Week 8 (7 medium): Graphs**
- Clone Graph, Course Schedule, Network Delay Time
- Cheapest Flights Within K Stops
- Reconstruct Itinerary

**Patterns:** Dijkstra, BFS on weighted graphs, DFS with backtracking

**Month 2 Goal:** 56/200 (28%) - Medium problems feel doable

---

### Month 3: Advanced Patterns (44 problems - 28 medium, 16 hard)

**Week 9 (11 medium/hard): Advanced DP**
- Longest Common Subsequence, Edit Distance
- Regular Expression Matching (hard)
- Interleaving String, Distinct Subsequences (hard)

**Patterns:** 2D DP, sequence matching, optimization

**Week 10 (11 medium/hard): Backtracking**
- Subsets, Subsets II, Permutations, Permutations II
- Combination Sum, Combination Sum II
- N-Queens (hard), Word Search II (hard)

**Patterns:** DFS with backtracking, pruning, state restoration

**Week 11 (11 medium/hard): Graphs (Advanced)**
- Word Ladder, Word Ladder II (hard)
- Alien Dictionary (hard), Graph Valid Tree
- Number of Connected Components

**Patterns:** BFS shortest path, graph construction, union-find

**Week 12 (11 hard): Hard Problems (Timed)**
- Trapping Rain Water, Largest Rectangle in Histogram
- Median of Two Sorted Arrays, Merge K Sorted Lists
- Serialize/Deserialize Binary Tree

**Patterns:** Stack tricks, binary search on answer, tree serialization

**Month 3 Goal:** 100/200 (50%) - Halfway there, hard problems approachable

---

### Month 4: Mastery (50 problems - 20 medium, 30 hard)

**Week 13 (12 medium): Timed Practice (20 min target)**
- Review medium problems, solve under time pressure
- Focus on explaining approach clearly
- Practice writing clean code fast

**Week 14 (13 hard): Hard DP & Greedy**
- Best Time to Buy/Sell Stock III, IV (hard)
- Burst Balloons (hard), Russian Doll Envelopes (hard)
- Jump Game II, Gas Station

**Week 15 (12 hard): Company-Tagged Problems**
- Google-tagged: Design Add and Search Words Data Structure (hard)
- Meta-tagged: Verifying an Alien Dictionary (hard)
- Amazon-tagged: LRU Cache (hard)

**Week 16 (13 hard): Contest Simulation**
- Participate in LeetCode Weekly Contest (4 problems, 1.5 hrs)
- Review solutions, upsolve problems you missed
- Practice explaining approach under pressure

**Month 4 Goal:** 150/200 (75%) - Interview-ready, confident on hard problems

---

### Month 5: Maintenance (30 problems - company-specific)

**Weeks 17-20 (30 medium/hard):**
- Focus on companies you're interviewing with
- Review previously solved problems (spaced repetition)
- 1 problem per day (stay sharp, don't burn out)
- Mock interview problems (Pramp, Interviewing.io)

**Company Focus:**
- **Google:** Graph, DP, Hard problems
- **Meta:** Arrays, Strings, Trees, Medium pace
- **Amazon:** Leadership Principles + Medium LC (2 problems in 45 min)
- **Apple:** System design + LC Medium

**Month 5 Goal:** 180/200 (90%) - Active interviewing, consistent practice

---

### Month 6: Contest Mode (20 problems - weekly contests)

**Weeks 21-24 (20 hard):**
- LeetCode Weekly Contest (every Sunday)
- Timed practice (30 min per hard problem)
- Review mistakes, identify patterns you're missing
- Warm up before real interviews (solve 1 easy morning-of)

**Month 6 Goal:** 200/200 (100%) - COMPLETE. Elite-level problem solver.

---

## Problem Selection Strategy

### Phase 1: Foundation (Months 1-2)

**Use NeetCode 150:** Curated list of most important problems
- [NeetCode.io](https://neetcode.io/practice) - Organized by pattern
- Watch video explanations if stuck (NeetCode YouTube)
- Focus on understanding patterns, not memorizing solutions

**How to solve:**
1. Read problem, clarify with examples
2. Attempt for 20-30 min (brute force is okay)
3. If stuck, read hints or watch video
4. Code the solution, test edge cases
5. Review time/space complexity
6. Add to spaced repetition (revisit in 1 week, 1 month)

---

### Phase 2: Pattern Mastery (Month 3)

**Target specific patterns:**
- Dynamic Programming (20 problems)
- Backtracking (15 problems)
- Graphs (15 problems)
- Trees (10 problems)

**How to practice:**
- Solve 3-4 similar problems in a row (pattern recognition)
- Compare solutions (iterative vs recursive, DP vs greedy)
- Explain approach out loud (mock interview practice)

---

### Phase 3: Company-Specific (Months 4-5)

**Use LeetCode filters:**
- Filter by company (Google, Meta, Amazon, etc.)
- Filter by frequency (sort by "asked in last 6 months")
- Focus on Medium (interview staple) and Hard (differentiation)

**Strategy:**
- Each company has a style (Google: hard, Amazon: 2 mediums)
- Practice in interview format (whiteboard, 45 min)
- Record yourself explaining solution (review communication)

---

### Phase 4: Contest Practice (Month 6)

**LeetCode Weekly Contest:**
- Every Sunday, 1.5 hours, 4 problems (easy â†’ medium â†’ hard â†’ very hard)
- Simulates real interview pressure
- Global ranking (motivating)

**Contest strategy:**
- Solve easy fast (5 min)
- Medium next (15-20 min each)
- Hard last (attempt even if you won't finish)
- Review editorial after (learn new patterns)

---

## Patterns to Master (with example problems)

### 1. Two Pointers
**When:** Sorted array, linked list, string matching
**Examples:** Two Sum II, 3Sum, Container With Most Water, Remove Nth Node
**Pattern:** Start/end pointers moving toward each other, or fast/slow pointers

### 2. Sliding Window
**When:** Subarray/substring problems (max/min length, fixed size)
**Examples:** Longest Substring Without Repeating, Minimum Window Substring
**Pattern:** Expand window (right++), contract when invalid (left++)

### 3. Hash Map / Set
**When:** Need O(1) lookup, counting, deduplication
**Examples:** Two Sum, Group Anagrams, Longest Consecutive Sequence
**Pattern:** Store seen elements, count frequencies, check existence

### 4. Binary Search
**When:** Sorted array, search space can be halved
**Examples:** Binary Search, Search in Rotated Array, Kth Smallest in Matrix
**Pattern:** `low`, `high`, `mid`, adjust based on comparison

### 5. DFS (Recursion)
**When:** Tree/graph traversal, backtracking, combinatorics
**Examples:** Number of Islands, Clone Graph, Subsets, Permutations
**Pattern:** Recursive call, base case, explore all branches

### 6. BFS (Queue)
**When:** Shortest path, level-order traversal, graph distance
**Examples:** Binary Tree Level Order, Word Ladder, Shortest Path in Grid
**Pattern:** Queue, visited set, process level-by-level

### 7. Dynamic Programming
**When:** Optimal substructure, overlapping subproblems
**Examples:** Climbing Stairs, Coin Change, Longest Increasing Subsequence
**Pattern:** `dp[i]` = solution for subproblem i, recurrence relation

### 8. Backtracking
**When:** Generate all combinations, permutations, subsets
**Examples:** Subsets, Permutations, N-Queens, Word Search
**Pattern:** DFS + undo choice (remove from current path)

### 9. Greedy
**When:** Local optimal leads to global optimal
**Examples:** Jump Game, Gas Station, Task Scheduler
**Pattern:** Make best choice at each step, prove correctness

### 10. Union-Find
**When:** Connected components, cycle detection
**Examples:** Number of Connected Components, Redundant Connection
**Pattern:** `parent[]` array, `find()`, `union()`, path compression

### 11. Heap (Priority Queue)
**When:** Kth largest/smallest, merge K sorted, median
**Examples:** Kth Largest Element, Merge K Sorted Lists, Find Median
**Pattern:** Min-heap or max-heap, extract/insert O(log n)

### 12. Trie (Prefix Tree)
**When:** Prefix search, autocomplete, word validation
**Examples:** Implement Trie, Word Search II, Design Add/Search Words
**Pattern:** Tree of characters, insert/search words

---

## How to Practice Each Problem

### First Attempt (30-45 min)

1. **Understand the problem** (5 min)
   - Read problem statement carefully
   - Write down examples (given + your own edge cases)
   - Clarify constraints (input size, edge cases)

2. **Think out loud** (10 min)
   - Identify pattern (two pointers? DP? Graph?)
   - Discuss brute force approach (even if slow)
   - Optimize (better data structure? Prune search space?)

3. **Write code** (15-20 min)
   - Start with clear variable names
   - Handle edge cases first (null, empty, single element)
   - Write clean code (not just "make it work")

4. **Test & debug** (5-10 min)
   - Run example test cases
   - Think of edge cases (empty, single element, all same, max size)
   - Dry run your code line-by-line

5. **Analyze complexity** (5 min)
   - Time: O(?) - count loops, recursion depth
   - Space: O(?) - extra arrays, recursion stack
   - Can you do better? (Is there O(n) instead of O(nÂ²)?)

**If stuck after 30 min:** Read hints or watch NeetCode video. Don't spin wheels for hours.

---

### Spaced Repetition (Review Schedule)

**After solving a problem:**
- Mark it in your tracker (easy/medium/hard, pattern, company tag)
- Add to review schedule:
  - **1 week later:** Solve again from memory (should be faster)
  - **1 month later:** Solve again (should remember pattern)
  - **Before interview:** Solve one more time (confidence)

**Why this works:** Spaced repetition moves knowledge from short-term to long-term memory. You'll recognize patterns in new problems faster.

---

## Problem Tracker Template

Use a spreadsheet (Google Sheets) or Notion to track:

| # | Problem | Difficulty | Pattern | Company | Date | Review 1 | Review 2 | Notes |
|---|---------|------------|---------|---------|------|----------|----------|-------|
| 1 | Two Sum | Easy | Hash Map | Google | 2025-01-01 | 2025-01-08 | 2025-02-01 | O(n) time, remember hash map |
| 2 | Add Two Numbers | Medium | Linked List | Meta | 2025-01-02 | 2025-01-09 | 2025-02-02 | Carry logic, dummy head |

**Track:**
- Problem name + link
- Difficulty (Easy/Medium/Hard)
- Pattern (Two Pointers, DP, etc.)
- Company tag (if applicable)
- Date solved
- Review dates (1 week, 1 month)
- Notes (key insight, mistake you made, optimization)

---

## Common Mistakes to Avoid

### 1. Random Problem Selection
**Wrong:** Picking problems randomly, no pattern focus
**Right:** Study 5-10 problems of same pattern (e.g., all Sliding Window)

### 2. Reading Solution Too Early
**Wrong:** Getting stuck for 5 min, immediately reading solution
**Right:** Struggle for 20-30 min, try brute force, then read hints

### 3. Not Reviewing
**Wrong:** Solve 200 problems once, forget everything
**Right:** Spaced repetition (1 week, 1 month), review mistakes

### 4. Ignoring Edge Cases
**Wrong:** Only testing happy path
**Right:** Test empty input, single element, all same, max constraints

### 5. Not Timing Yourself
**Wrong:** Spending 2 hours on medium problem
**Right:** 30-45 min limit, then move on (interview simulation)

### 6. Only Coding, Not Explaining
**Wrong:** Silent coding, no communication
**Right:** Talk through approach, explain trade-offs (interview practice)

---

## Daily Practice Schedule

### Weekdays (2 hours)

**0-30 min:** Warm-up (1 easy problem)
- Previously solved problem from 1 month ago
- Or new easy problem for confidence

**30-90 min:** Main problem (1 medium or hard)
- First attempt (30-45 min)
- If stuck, read hints/video (15 min)
- Code solution, test, analyze complexity (15 min)

**90-120 min:** Review or Android learning
- Review solution, understand optimizations
- Add to tracker, schedule review
- Or switch to Android project work

---

### Weekends (6 hours)

**0-120 min:** Deep LeetCode session (2-3 problems)
- 1 medium (30 min)
- 1 hard (45 min)
- 1 review from last week (20 min)

**120-360 min:** Android project building
- Focus on portfolio projects (ElevenLabs, Midnight Wallet, AI Chat)
- LeetCode in the morning, project in afternoon

**Sunday:** Participate in LeetCode Weekly Contest (1.5 hrs)
- Real-time competition, pressure simulation
- Review editorial, learn new patterns

---

## Company-Specific Focus (Month 5-6)

### Google
**Difficulty:** Hard-heavy (expect 1-2 hard in onsite)
**Patterns:** Graphs, DP, Trees, System Design
**Practice:** 20 Google-tagged hard problems
**Tip:** Explain optimizations, discuss trade-offs

### Meta (Facebook)
**Difficulty:** Medium-heavy (fast-paced, 2 problems in 45 min)
**Patterns:** Arrays, Strings, Trees, DFS/BFS
**Practice:** 20 Meta-tagged medium problems
**Tip:** Code fast but clean, communicate clearly

### Amazon
**Difficulty:** Medium (2 problems in 45 min + behavioral)
**Patterns:** Arrays, Strings, Trees, DP basics
**Practice:** 20 Amazon-tagged medium problems
**Tip:** Tie solutions to Leadership Principles

### Apple
**Difficulty:** Medium (1-2 problems + system design)
**Patterns:** Arrays, Trees, Design problems
**Practice:** 15 Apple-tagged medium + system design
**Tip:** Focus on clean code, edge cases

---

## Resources

### Problem Lists
- **[NeetCode 150](https://neetcode.io/practice)** - Best curated list, video explanations
- **[Blind 75](https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU)** - Classic must-solve problems
- **[Grind 75](https://www.techinterviewhandbook.org/grind75)** - Customizable study plan

### Video Explanations
- **[NeetCode YouTube](https://www.youtube.com/c/NeetCode)** - Best explanations, clear visuals
- **[Back to Back SWE](https://www.youtube.com/c/BackToBackSWE)** - In-depth algorithm analysis
- **[Kevin Naughton Jr.](https://www.youtube.com/c/KevinNaughtonJr)** - Lots of problems solved

### Books
- **"Cracking the Coding Interview"** by Gayle Laakmann McDowell - Interview strategies
- **"Elements of Programming Interviews"** (Java/Python/C++) - Advanced patterns

### Platforms
- **[LeetCode](https://leetcode.com/)** - Primary platform (Premium worth it for company tags)
- **[HackerRank](https://www.hackerrank.com/)** - Alternative, some companies use for assessments
- **[CodeSignal](https://codesignal.com/)** - Real company assessments

---

## Motivation & Mindset

### It's a Marathon, Not a Sprint
- 200 problems over 6 months = ~1 problem per day
- Some days you'll solve 3, some days 0 - that's okay
- Consistency > intensity (better to do 30 min daily than 5 hrs once a week)

### Hard Problems Are Supposed to Be Hard
- Top 1% of engineers struggle with hard LC
- If you solve it in 45 min after seeing the pattern, you're doing great
- FAANG doesn't expect you to solve every hard problem perfectly

### Your Advantage: CS Degree
- You've seen algorithms before (UT Austin CS)
- This is a refresh, not learning from scratch
- You'll progress faster than bootcamp grads

### Track Progress Visually
- Spreadsheet with 200 rows, check them off
- Graph your progress (50/200, 100/200, 150/200)
- Celebrate milestones (every 50 problems)

---

**Start with NeetCode Easy problems. Build momentum. By Month 3, hard problems will feel approachable. By Month 6, you'll be in the top 10% of interview candidates.**

**You got this. One problem at a time.** ðŸš€
